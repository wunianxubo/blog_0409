---
title: Java内存模型  
date: 2017-08-14 19:58:00  
tags: [java,java并发]    
categories: java  
---
# 一、Java内存模型的抽象结构
&emsp;&emsp;**java内存模型（JMM）是java线程之间的通信控制机制，JMM决定一个线程对共享变量（实例域、静态域和数组）的写入何时对另一个线程可见，java内存模型的主要目标是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。**   
&emsp;&emsp;JMM定义了线程和主内存之间的抽象关系：**线程之间的共享变量（实例域、静态域和数组元素）存储在主内存中，每个线程都有一个私有的本地内存（存放局部变量，方法定义参数和异常处理器参数），本地内存中存储了该线程以读、写共享变量的副本。**   
![image](http://osrmzp0jr.bkt.clouddn.com/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.png)

线程A与B之间要通信的话，必须经历以下两个步骤：  
**1、线程A把本地内存A中更新过的共享变量刷新到主内存中  
2、线程B到主内存中去读取线程A之前已更新过的共享变量**  

![image](http://osrmzp0jr.bkt.clouddn.com/22.png)  

### 1、指令重排序  
重排序是指编译器和处理器为了优化程序性能而对指令序列进行重新排序的一种手段。  
**①编译器优化的重排序**：编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。  
**②指令级并行的重排序**：如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。  
**③内存系统的重排序**：由于处理器使用缓存和读、写缓冲区，这使得加载和存储操作看上去可能在乱序执行。  
&emsp;&emsp;①属于编译器重排序，②、③属于处理器重排序。**对于编译器，JMM的编译器重排序规则会禁止特定类型的编译器重排序。对于处理器重排序，JMM的处理器重排序规则会要求Java编译器在生成指令序列时，插入特定类型的内存屏障指令，通过内存屏障指令来禁止特定类型的处理器重排序。** 通过禁止特定类型的编译器重排序和处理器重排序，提供了一致的内存可见性保证。  

### 2、内存屏障（Memory Barrier）
内存屏障，又称内存栅栏，是一个CPU指令，主要实现两个功能：  
**1、保证特定操作的执行顺序。插入一条内存屏障，会告诉编译器和CPU，不管什么指令都不能和这条内存屏障指令重排序。  
2、强制刷出各种CPU缓存，确保内存数据的可见性。**  

### 3、数据依赖性  
如果两个操作访问同一个变量，且这两个操作中有一个为写操作，此时这两个操作之间就存在数据依赖性。**编译器和处理器在重排序时，会遵守数据依赖性，不会改变存在数据依赖性关系的两个操作的执行顺序。**  

### 4、as-if-serial语义  
**as-if-serial语义的意思是：不管怎么重排序，（单线程）程序的执行结果不能被改变。** 所以编译器和处理器不会改变存在数据依赖性关系的两个操作的执行顺序。

### 5、顺序一致性内存模型
是一个理想化的内存模型，一个线程中所有操作必须按照程序的顺序来执行。在顺序一致性内存模型中，每个操作都必须原子执行且立刻对所有线程可见。  

### 6、happens-before规则
在JMM中，如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须要存在happens-before关系。  
**一个happens-before规则对应于一个或者多个编译器和处理器重排序规则。**  
①程序顺序规则：一个线程中的每个操作，happens-before于该线程中的任意后续操作。  
②监视器锁规则：对一个锁的解锁，happens-before于随后对这个锁的加锁。  
③volatile变量规则：对一个volatile域的写，happens-before于任意后序对这个volatile域的读。  
④传递性：如果A happens-before B，且B happens-before C，那么A happens-before C。  
**注意：两个操作之间具有happens-before关系，并不意味着前一个操作必须在后一个操作之前执行！仅仅是要求前一个操作（执行的结果）对后一个操作是可见的，且前一个操作按顺序在第二个操作之前。**  

# 二、JVM对Java内存模型的实现
在JVM内部，Java内存模型把内存分成了两部分：线程栈区和堆区，如下图：  
![image](http://osrmzp0jr.bkt.clouddn.com/jvm1.png)  
**JVM中运行的每个线程都拥有自己的线程栈，包含了当前线程执行的方法调用信息，还包含了当前方法的所有本地变量信息，是线程私有的。    
堆区包含了Java应用创建的所有对象信息，不管对象的引用是属于一个成员变量还是方法中的本地变量，对象都会被存储在堆区。**  

下图展示了调用方法和本地变量存储在栈区，对象都存储在堆区：  
![image](http://osrmzp0jr.bkt.clouddn.com/jvm2.png)  

**1、一个本地变量如果是原始类型，那么存储在栈区；  
2、一个本地变量可能是一个对象的引用，这种情况下，这个引用会被存储在栈中，但是对象本身仍然存储在堆区；  
3、对于一个对象的成员方法，这些方法中包含本地变量，需要存储在栈中，即使所属的对象在堆区；  
4、对于一个对象的成员变量，不管是原始类型还是包装类型，都被存储在堆区；  
5、static类型的变量存储在堆区**  

**堆中的对象可以被多线程共享。如果一个线程获得一个对象的引用，它就可以访问这个对象的成员变量；如果两个线程同时调用了同一个对象的同一个方法，那么这两个线程便可以同时访问这个对象的成员变量，但是对于对象的本地变量，每个线程都会拷贝一份到自己的线程栈中。** 如下图所示：  
![image](http://osrmzp0jr.bkt.clouddn.com/jvm3.png)  

## 硬件内存架构
**当一个CPU需要访问主存时，会先去读取一部分主存数据到CPU缓存（CPU Cache），再读取CPU缓存到寄存器（CPU Registers）。当CPU需要写数据到主存时，同样会先flush寄存器到CPU缓存，然后在适当的时候把缓存数据flush到主存。**  
![image](http://osrmzp0jr.bkt.clouddn.com/jvm4.png)  

## Java内存模型和硬件内存架构之间的关系
**Java内存模型和硬件内存架构不是一致的。硬件架构中并没有区分栈和堆，从硬件上看，不管是栈还是堆，大部分数据都会存到主存中，还有一部分会存到缓存和寄存器中。** 他们之间的关系如下图：  
![image](http://osrmzp0jr.bkt.clouddn.com/jvm5.png)  

当对象和变量存储到不同的内存区域后，会出现一些问题：  
**1、共享对象对各个线程的可见性  
2、共享对象的竞争现象**  
### 共享对象的可见性
**当多个线程同时操作一个共享对象时，如果没有合理使用volatile和synchronized关键字，一个线程对共享对象的更新可能导致其他线程不可见。**  
左边CPU中运行的线程从主存中拷贝共享对象obj到它的缓存，把obj的count改为2。但这个更新对右边CPU不可见，因为这个更新还没flush到主存中。可以使用volatile关键字解决问题。    
如下图：  
![image](http://osrmzp0jr.bkt.clouddn.com/jvm6.png)
### 竞争现象
如果多个线程共享一个对象，如果它们同时修改这个共享对象，这就产生了竞争现象。如下图所示，线程A、B共享一个对象obj，假设线程A、B从主存读取obj.count变量到自己的CPU缓存，并且两个线程都对obj.count做了加1操作，加1操作被执行了两个，最后count的值却为2。使用synchronized代码块解决问题，**synchronized代码块可以保证同一个时刻只能有一个线程进入代码块，也能保证代码块中的所有变量从主存中去读，当线程退出代码块时，对所有变量的更新都会立即flush到主存。**  
![image](http://osrmzp0jr.bkt.clouddn.com/jvm6.png)




