---
title: synchronized的实现原理及锁的升级
date: 2017-08-13 16:37:25
tags: [java,java并发]  
categories: java
---
# 一、synchronized的实现原理
Java中的每一个对象都可以作为锁，有三种形式：  
**1、对于普通同步方法，锁是当前实例对象。  
2、对于静态同步方法，锁是当前类的Class对象。  
3、对于同步代码块，锁是Synchronized括号中配置的对象.**   

由JVM规范，**JVM基于进入和退出Monitor对象来实现方法同步和代码块同步**，但两者实现细节不一样。  
**1、代码块同步是使用monitorenter和monitorexit指令实现的。  
2、方法同步则是依靠方法修饰符上的ACC_SYNCHRONIZED实现**。  

## 实现原理
monitorenter指令是在编译后插入到同步代码块的开始位置，而monitorexit是插入到方法结束处和异常处。**任何一个对象都有一个monitor与之关联。当且一个monitor被持有后，它将处于锁定状态。线程执行到monitorenter指令时，将会尝试获取对象所对应的monitor的所有权，即尝试获得对象的锁。**  
&emsp;&emsp;**而synchronized用的锁是存放在Java对象头中的。**

## Java对象头  
HotSpot虚拟机中，对象在内存中的布局分为三块区域：对象头、实例数据和对齐填充。  
### 对象头  
**对象头包括两部分：Mark Word 和 类型指针**。  

**Mark Word**  
**Mark Word用于存储对象自身的运行时数据，如哈希吗（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳**等，占用的内存大小和虚拟机的位长一致。  
  
**类型指针**  
**类型指针指向对象的类元数据，虚拟机通过这个指针确定该对象是哪个类的实例。**   
 
&emsp;&emsp;在对象处于未被锁定的情况下，mark word的32bit空间中有25bit存储对象的哈希吗、4bit存储对象的分代年龄、2bit存储锁的标记位、1bit固定为0。

# 锁的升级和对比  
&emsp;&emsp;为了减少获得锁和释放锁带来的性能消耗，引入了“偏向锁”和“轻量级锁”，锁共有四种状态：**无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态。**  
## 1、偏向锁  
&emsp;&emsp;大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低引入了偏向锁。  
&emsp;&emsp;**当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁。轻量级锁的获取及释放依赖多次CAS原子指令，而偏向锁只需要一次CAS原子指令来置换线程ID**。  
**（1）偏向锁的获取**   
1、通过 markOop mark = obj->mark() 获取对象的markOop数据mark，即对象头的Mark Word；  
2、判断mark是否为可偏向状态，即Mark的偏向锁标志位为1，锁标志位为01；  
3、判断mark中Java Thread的状态：如果为空，则进入步骤4；如果指向当前线程，则执行同步代码块；如果指向其它线程，进入步骤5；  
4、通过CAS原子指令设置mark中Java Thread为当前线程ID，如果执行CAS成功，则执行同步代码块，否则进入步骤5；  
5、如果CAS执行失败，表示当前存在多个线程竞争锁，当达到全局安全点（safepoint），获得偏向锁的线程被挂起，撤销偏向锁，并升级为轻量级锁，升级完成后被阻塞在安全点的线程继续执行同步代码块。  
**（2）偏向锁的撤销**  
①偏向锁使用了一种等到竞争出现才会释放锁的机制，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。  
②偏向锁的撤销，需要等待全局安全点（在这个时间点上没有正在执行的字节码）。  
③暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否活着。  
④如果线程不处于活动状态，则将对象头设置成无锁状态；撤销偏向锁，恢复到无锁（标志位为01）或轻量级锁（标志位为00）的状态。   
**（3）偏向锁的关闭**  
偏向锁默认开启，但会在应用程序启动几秒后才激活。使用JVM参数关闭延迟：-XX：BiasedLockingStartupDelay=0。如果确定应用程序里所有的锁通常都处于竞争状态下，通过JVM参数关闭偏向锁：-XX:-UseBiasedLocking=false，那么程序会默认进入轻量级锁状态。  

![image](http://osrmzp0jr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-04-10%20%E4%B8%8B%E5%8D%883.10.30.png)
## 2、轻量级锁  
&emsp;&emsp;**引入轻量级锁的目的：**在多线程**交替执行**同步块时，尽量避免重量级锁引起的性能消耗，**但是如果多个线程在同一时刻进入临界区，会导致轻量级锁膨胀升级为重量级锁。**  
**（1）轻量级锁的获取**  
当关闭偏向锁功能，或多个线程竞争偏向锁导致偏向锁升级为轻量级锁时，会尝试去获取轻量级锁。  
1、通过 markOop mark = obj->mark() 获取对象的markOop数据mark，即对象头的Mark Word；  
2、通过mark->is_neutral()方法判断mark是否为无锁状态：mark的偏向锁标志位为0（偏向锁关闭），锁标志位为01（无锁状态）；  
3、如果mark处于无锁状态，则进入步骤4，否则进入步骤6；  
4、把mark（对象头的Mark Word）复制到锁记录中（线程在执行同步块之前，JVM会现在当前线程的栈帧中创建用于存储锁记录的空间，_displaced_header字段）；  
5、通过CAS尝试将Mark Word更新为指向锁记录的指针，如果更新成功，表示竞争到锁，执行同步代码，否则执行步骤6；  
6、如果当前mark处于加锁状态，并且mark中的ptr指针指向当前线程的栈帧，则执行同步代码，否则说明有多个线程竞争轻量级锁，轻量级锁需要膨胀升级为重量级锁。  

**假设线程A和B同时执行到临界区**  
1、线程A、B都把Mark Word复制到各自的锁记录（_displaced_header字段），该数据保存在线程的栈帧上，是线程私有的；    
2、CAS操作保证只有一个线程可以将Mark Word更新为指向锁记录的指针，假设A执行成功，并返回继续执行同步代码块；  
3、线程B的CAS操作失败，退出临界区，通过 ObjectSynchronizer::inflate方法开始膨胀锁。  

**（2）轻量级锁的解锁** 
轻量级锁解锁时，会使用CAS操作将锁记录中复制来的Mark Word重新替换回对象头。如果CAS成功，表示没有竞争发生，解锁成功；如果CAS失败，表示当前锁竞争存在，锁就会膨胀成重量级锁。  

![image](http://osrmzp0jr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-04-10%20%E4%B8%8B%E5%8D%883.14.37.png)
## 3、重量级锁  
&emsp;&emsp;重量级锁通过对象内部的监视器（monitor）实现，其中monitor的本质是依赖于底层操作系统的Mutex Lock实现，操作系统实现线程之间的切换需要从用户态切换到内核态，切换成本非常高。  
&emsp;&emsp;**因为自旋会消耗CPU，为了避免无用的自旋（比如获得锁的线程被阻塞住了），一旦锁升级成重量级锁，就不会再恢复到轻量级锁状态。** 在这个状态下，其他线程试图获取锁时，都会被阻塞住，当持有锁的线程释放锁之后才会唤醒这些线程，被唤醒的线程就会进行新的一轮夺锁之争。  

## 锁的优缺点对比
锁 | 优点 | 缺点 | 适用场景
---|---|---|---
偏向锁 | 加锁和解锁不需要额外的消耗,和执行非同步方法相比仅存在纳米级的差距 | 如果线程间存在锁竞争，会带来额外的锁撤销的消耗 | 适用于只有一个线程访问同步块的场景
轻量级锁 | 竞争的线程不会阻塞，提高了程序的响应速度 | 如果始终得不到锁竞争的线程，使用自旋会消耗CPU | 追求响应时间，同步块执行速度非常快
重量级锁 | 线程竞争不使用自旋，不会消耗CPU | 线程阻塞，响应时间缓慢 | 追求吞吐量，同步块执行速度较长