---
title: 分布式系统互斥性与幂等性问题的分析和解决
date: 2018-04-09 09:26:00  
tags: [大型网站技术架构,分布式系统]    
categories: 分布式系统
---
## 前言
分布式系统由独立的服务器通过网络松散耦合组成。在这个系统中，每个服务器都是一个独立的主机，服务器之间通过内部网络连接。分布式系统有以下几个特点：  

- 可扩展性：可通过横向水平扩展来提高系统的性能和吞吐量。  
- 高可靠性：高容错，即使系统中一台或几台故障，系统通过失效转移仍然可以提供服务。  
- 高并发性：各机器并行独立处理和计算。  
- 廉价高效：多台小型机而非单台高性能机。  

在分布式系统中，环境复杂、网络不稳定性会造成诸如时钟不一致的问题，存在于集中式系统中机器宕机、消息丢失等问题也会在分布式环境中变得更加复杂。有两个问题是分布式环境中需要重点关注和解决的典型问题：  

- 互斥性问题
- 幂等性问题  

<!-- more -->
## 一、互斥性问题
看个例子：  
某服务器提供一组任务，A请求随机从任务组中获取一个任务；B请求随机从任务组中获取一个任务。在理想情况下，A从任务组中挑选一个任务，任务组删除该任务，B从剩下的任务组中再挑一个，之后任务组再删除。  
但在真实情况下，如不做任何处理，可能出现A和B挑中了同一个任务的情况。  

上面这个例子，存在操作互斥性的问题，其实就是对共享资源的抢占问题。如果不同的请求对同一个或者同一组资源读取并修改时，无法保证其按序执行，无法保证一个操作的原子性，那么就很有可能会出现预期外的情况。所以操作的互斥性问题可以理解为一个需要保证时序性、原子性的问题。  

在传统的基于数据库的架构中，对于数据的抢占问题往往是通过数据库事务（ACID）来保证的。在分布式环境中，**分布式锁**是一种比较常见和高效的解决方案。在传统的多线程、多进程情况下，已有比较好的解决方案，我们先来看看传统情况下是怎么解决的。  

### 多线程环境下的解决方案  
**基本上所有的并发模式在解决线程冲突的问题上，都是采用序列化访问共享资源的方式。**  
在多线程环境下，最普遍的方式就是用互斥锁把该资源或对资源的操作保护起来。Java中提供两种互斥锁Lock和synchronized。不同线程之间对同一资源进行抢占，该资源通常表现为某个类的普通成员变量，使用Lock和synchronized将共享的变量及其操作锁住，就可以解决资源抢占的问题。  

### 多进程的解决方案 
在多道程序系统中存在许多进程，它们共享各种资源，然而有很多资源一次只能供一个进程使用，这便是临界资源。多进程中的临界资源大致可以分为两类，一类是物理上的真实资源，如打印机；一类是硬盘或内存中的共享数据，如共享内存等。进程内互斥访问临界资源的代码称为**临界区**。  
对于临界资源的互斥访问，JVM层面的锁已经失去作用了。在多进程情况下，主要还是利用操作系统层面的进程间通信原理来解决临界资源的抢占问题。比较常见的一种方法是使用信号量（Semaphores）  
信号量分为有名信号量和无名信号量。无名信号量通常保存在共享内存中，而有名信号量是于一个特定的文件夹名称相关联。对信号量的操作主要是P操作（wait）和V操作（signal）。  

- P操作：先检查信号量的大小，若值大于零，则将信号量减1，同时进程获得共享资源的访问权限，继续执行；若小于或者等于零，则该进程被阻塞后，进入等待队列。  
- V操作：该操作将信号量的值加1，如果有进程阻塞着等待该信号量，那么其中一个进程被唤醒。  

对共享资源的操作前后（进入和退出临界区）进行加锁和解锁，保证不同线程或进程可以互斥有序的操作资源。  

### 分布式环境下的解决方案——分布式锁
不管是多线程还是多进程环境下的锁都有很多共通之处，他们满足一些最基本的条件：  
1. 需要有存储锁的空间，并且锁的空间是可以访问到的。  
2. 锁需要被唯一标识（全局唯一）。  
3. 锁至少要有两种状态，如ReetrantLock中的status，0表示没有线程竞争，大于0表示有线程竞争；或者是有锁、没锁这样分类。  

有了这三个条件，就可以基本上实现一个简单的分布式锁了。以数据库为例，实现一个简单的分布式锁：数据库表，字段为锁的ID（唯一标识），还有锁的状态（0表示没锁，1表示被锁）。  
```
lock = mysql.get(id);
while(lock.status == 1)  //已被锁，继续等待获取
    sleep(100);
mysql.update(lock.status = 1);  //获取到锁，更新锁状态为被锁 
doSomthing();  //执行逻辑
mysql.update(lock.status = 0);  //释放锁，更新锁状态
```
#### 问题
上面简单的实现了一个分布式锁，但是存在一些问题：  

- 问题1：锁状态判断的原子性无法保证   
从读取锁的状态，到判断该状态是否为被锁，这两个操作如果不能保证是原子性的，就可能导致不止一个请求获取到了锁，这显然是不行的。  
- 问题2：网络断开或主机宕机，锁状态无法清除
假设主机在获取到锁的情况下，突然出现了网络断开或者主机宕机，如果不做任何处理该锁将仍然处于被锁定的状态。那么之后的所有请求都无法再成功抢占到这个锁。因此，我们需要在持有锁的主机遇到网络断开或者主机宕机时，及时的释放掉这把锁。  
- 问题3：无法保证释放的是自己上锁的那把锁  
如果持有锁的主机A在临界区遇到网络抖动而导致网络断开，分布式锁及时的被释放了。之后，另一个主机B占用了这把锁，但是此时主机A网络恢复，退出临界区并解锁。由于都是一把锁，所以数据库中锁的状态会变为无占用状态；如果此时第三个主机C尝试抢占这把锁，也将会成功获得。因此，我们需要在解锁时，确定自己解的这个锁是否还是当前主机还依旧占用的这把锁（因为可能在这之前这把锁已经被释放过了）。  

#### 进阶条件
分布式锁的实现，如果可以解决上面三个问题，可以算是一个相对完整的分布式锁了。在实际情况中，可能有更高级的要求。  
1. 可重入：线程中的可重入，指的是外层函数获得锁之后，内层也可以获得锁，Lock和synchronized都是可重入锁；在分布式环境中，一般还是指的线程的可重入。  
2. 惊群效应（Herd Effect）：在分布式锁中，惊群效应指的是，在有多个请求等待获取锁的时候，一旦占有锁的线程释放之后，如果所有等待方都被同时唤醒，尝试抢占锁。但是这样的情况会造成比较大的开销，应避免惊群效应的产生。  
3. 公平锁于非公平锁：不同需求下可能需要不同分布式锁。非公平锁开销较小，但如果业务需求竞争者按顺序获得锁，那么就需要实现公平锁。  
4. 阻塞锁和自旋锁：阻塞锁需要上下文的切换，或并发量高且临界区的操作耗时比较短，那么性能开销会比较大。如果临界区操作耗时比较长，一直保持自旋，也会对CPU造成更大的负荷。  

#### 典型实现
##### Zookeeper的实现
Zookeeper中有一种节点叫做顺序节点，假如我们在/lock/目录下创建三个节点，zk集群会按照发起创建的顺序来创建节点，节点分别为/lock/00000001、/lock/00000002、/lock/00000003。  
zk中还有一种名为临时节点的节点，临时节点由某个客户端创建，当客户端于zk集群断开连接，则该节点自动被删除。  

根据zk中节点是否存在，可以作为分布式锁的锁状态，以此来实现一个分布式锁，下面是分布式锁的基本逻辑：  
1. 客户端调用create()方法创建名为"/dlm-locks/lockname/lock-"的临时顺序节点。  
2. 客户端调用getChildren("lockname")方法来获取所有已经创建的子节点。
3. 客户端获取到所有子节点path之后，如果发现自己在步骤1中创建的节点是所有节点中序号最小的，那么久认为这个客户端获得了锁。  
4. 如果创建的节点不是所有节点中最小的，那么则监视比自己创建节点的序列号小的最大的节点，进入等待。直到下次监视的子节点变更的时候，再进行子节点的获取，判断是否获取锁。  

释放锁的过程相对比较简单，就是删除自己创建的那个子节点即可。  

##### Redis的实现
Redis的分布式缓存特性使其成为了分布式锁的一种基础实现。通过Redis中是否存在某个锁ID，则可以判断是否已经上锁。为了保证判断锁是否存在的原子性，保证只有一个县城获取同一把锁，Redis有SETNX(set if not exist)和GETSET（先写新值，返回旧值，原子性操作，用于分辨是不是首次操作）。  

为了防止主机宕机和网络断开之后的死锁，Redis没有zk那种天然的实现方式，只能依赖设置超时时间来规避。  

下面是一种比较普遍但不太完善的Redis分布式锁的实现步骤：  
1. 线程A发送SETNX lock.orderid尝试获得锁，如果锁不存在，则set并获得锁。  
2. 如果锁存在，则再判断锁的值（时间戳）是否大于当前时间，如果没有超时，则等待下再重试。  
3. 如果已经超时，再用GETSET lock.orderid来尝试获取锁，如果这时候拿到的时间戳仍然超时，那么说明已经获得锁了。  
4. 如果在此之前，另一个线程C快一步执行了上面的操作，那么A拿到的时间戳是个未超时的值，这是A没有如期获得锁，需要再次等待或重试。

##### Tair的实现
实现与Redis类似，Tair客户端封装了一个expireLock的方法：通过锁状态和过期时间戳来共同判断锁是否存在，只有锁已经存在且没有过期的状态才判定为有锁状态。在有锁的情况下，不能加锁，能通过大于或等于过期时间的时间戳进行解锁。  

采用这种方式，可以不用再Value中存储时间戳，并且保证了判断是否有锁的原子性。并且，由于超时时间由Tair判断，所以避免了不同主机时钟不一致的情况。  

##### 分布式锁的弊端
- 强依赖于外部组件：分布式锁的实现都依赖于外部数据存储如zk、Redis等，因此一旦这些外部组件出现故障，那么分布式锁就不可用了。  
- 无法完全满足需求：不同分布式锁的实现，都有相应的特点，对于一些需求并不能很好的满足，如实现公平锁、给等待锁加超时时间等等。  

基于以上的问题，结合多种的实现方式，美团开发了Cerberus，提供更灵活可靠的分布式锁。Cerberus有以下特点：  
1. 一套接口多种引擎。使用了多种引擎实现方式（Tair、ZK、未来支持Redis），可自主选择所需的一种或多种引擎。
2. 使用灵活，学习成本低。提供一套API，方便使用。  
3. 支持一键降级。可以实时切换引擎的接口，用于应对所依赖主引擎的故障发生。

## 二、幂等性问题
幂等，就是对接口的多次调用所产生的结果和调用一次是一致的。这里的接口，可以是对外发布的HTTP接口或者Thrift接口，也可以是接收消息的内部接口，或者是一个内部方法或操作。  
比如以下例子：  

- 在App下单的时候，点击确认之后没反应，就又点击几次。在这种情况下，如果无法保证该接口的幂等性，那么将会出现重复下单问题。  

在分布式环境中，网络环境更加复杂，因前端操作抖动、网络故障、消息重复、响应速度慢等原因，对接口重复调用概率会比集中式环境下更大，尤其是重复消息在分布式环境中很难避免。  

### 实现方式
- 业务操作本身就具有幂等性。
- 系统缓存所有请求与处理结果，检测到重复请求之后，自动返回之前的处理结果。

分布式环境中，有些接口是天然保证幂等性的，如查询操作。有些对数据的修改是一个常量，并且无其他记录和操作，那么也可以说是具有幂等性的。其他情况下，会涉及对数据的修改、状态的变更就有必要防止重复性操作的发生，我们需要通过实现接口的幂等性来防止重复操作所带来的影响。 

### GTIS
是分布式环境下幂等性的一个解决方案，能确保在分布式环境下操作的唯一性。  
#### 基本原理
GTIS实现思路是将每一个不同的业务操作赋予其唯一性。这个唯一性通过对不同操作所对应的唯一的内容特性生成一个唯一的全局ID来实现的。基本原则是：相同的操作生成相同的全局ID；不同的操作生成不同的全局ID。  

生成的全局ID需要存储在外部存储引擎中，数据库、Redis或者是Tair均可以实现。考虑到Tair天生分布式和持久化的优势，目前GTIS存储在Tair中。其对应的key和value如下：  
- key：将对于不同的业务，采用APP_KEY + 业务操作内容特性生成一个唯一标识trans_contents。然后对唯一标识进行加密生成全局ID作为Key。  
- value：current_timestamp + trans_contents，current_timestamp用于标识当前的操作线程。  

判断是否重复，主要采用Tair的SETNX方法，如果原来没有值则set且返回成功，如果已经有值则返回失败。  
#### 内部流程
GTIS内部的实现流程为：  
1. 业务方在业务操作之前，生成一个能够唯一标识该操作的transContents，传入GTIS；
2. GTIS根据传入的transContents，用MD5生成全局ID；
3. GTIS将全局ID作为key，current_timestamp + trans_contents作为value放入Tair进行setNx，将结果返回给业务方；
4. 业务方根据返回结果确定能否开始进行业务操作；
5. 若能，开始进行操作；若不能，则结束当前操作；
6. 业务方将操作结果和请求结果传入GTIS，系统进行一次请求结果的检验；
7. 若盖茨操作成功，GTIS根据Key取出value值，跟传入的返回结果进行对比，如果两者相同，则将全局ID的过期时间改为较长时间；
8. GTIS返回最终结果。  

![image](http://osrmzp0jr.bkt.clouddn.com/gtis_principle.jpg)