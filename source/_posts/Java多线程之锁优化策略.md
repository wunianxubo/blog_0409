---
title: Java多线程之锁优化策略  
date: 2017-09-30 10:26:04  
tags: [java,java并发]    
categories: java  
---
# 一、编码过程中可采取的锁优化的思路：
## 1、减少锁持有时间
如：对一个方法加锁，不如对方法中需要同步的几行代码加锁。  
## 2、减小锁粒度
如：jdk1.6中，  ConcurrentHashMap中采取对segement加锁而不是整个map加锁，提高并发性。类似数据库中的行锁对表锁的优势。  
## 3、锁分离
根据同步操作的性质，把锁划分为读锁和写锁，读锁之间不互斥，提高了并发性。  
## 4、锁粗化
在一个间隔性需要执行同步语句的线程中，如果在不连续的同步块间频繁加锁解锁是很耗性能的，因此把加锁范围扩大，把这些不连续的同步语句进行一次性加锁解锁。虽然线程持有锁的时间增加了，但是总体还是优化了的。  
## 5、锁消除
锁消除是编译器做的事：根据代码逃逸技术，如果判断到一段代码中，堆上的数据不会逃逸当前线程（即不会影响线程外的数据），那么可以认为这段代码是线程安全的，不需要加锁。  

# 二、Java虚拟机中采用的锁优化策略：
主要包括偏向锁、轻量级锁和自旋锁。其中，[偏向锁、轻量级锁及重量锁及其膨胀过程在之前博客中有了详细描述，](http://xiaonanbobo.com/2017/08/13/synchronized的实现原理及锁的升级/)在这篇文章，我主要介绍下自旋锁。  
## 自旋锁
如果当线程申请锁时，发现锁被占用，就让当前线程执行忙循环（自旋），观察持有锁的线程是否会很快释放锁。如果自旋后还没获得锁，才进入同步阻塞状态。  
### 自适应自旋
自旋的线程的自旋时间为在同一个锁上，上一次线程自旋并获得锁的耗时。如果对于这个锁，自旋很少成功，就不自旋了，避免浪费CPU资源。 

&emsp;**为了尽量避免使用重量级锁，JVM首先会尝试轻量级锁，轻量级锁尝试使用CAS操作来获取锁，如果轻量级锁获取失败，说明存在竞争，但是可能很快就能获得锁，就会尝试自旋锁，将线程做几个空循环，每一次循环都不断尝试获得锁。如果自旋锁也失败，那么只能升级为重量级锁。**